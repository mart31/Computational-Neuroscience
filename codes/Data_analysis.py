# -*- coding: utf-8 -*-
"""
Created on Wed Aug 17 08:42:15 2016

@author: martin
"""


import matplotlib.pyplot as plt
import csv
import numpy
import os
import sauvegarde_graphique

"""
For this module i used a 30cm nerve that i cut the first and last 5cm. It is possible
that some of the function does not work properly if you use another sized nerve.
"""


"""
This module is all about using the data generated by the nerve simulation module. Also
it used the sauvegarde_graphique module to save some of the graph.
"""
class Use_data(object):
    """
    before using a set of data you need to know the diameter of every axon the
    length of the nerve and the time array that was used to generate these datas
    """
    def __init__(self,sol_folder,files_names,dmg_file,length,d,t):
        self.diameters_array = d # diameter of the differents axons
        
        self.length = length # the length of the nerve
        self.files_names = files_names # The name of the files containing the solution
                         
        self.number_axons = 20 # i use exactly 20 neuron in all the simulation using less or more may invalidate some of the code
        self.sol_folder = sol_folder #the folder name in axon_sol_csv folder containing the data needed
        self.dmg_file = dmg_file # the folder name in axon_sol_csv folder containing the damage array
        self.temps = t # the time array
        self.sol_array = self.download_axons_solutions() #the action potential data of each axon is stored here
        
        self.dmg_array = self.download_dmg_array() 
        self.ap_speed = 0.0 # the action potential speed of every axon it is a average speed
        self.nerve_ap = 0.0 # the detail are explained at the calculated nerve ap function
        self.nerve_ap_speed = 0.0 # similar to calculate_nerve_ap
        self.width_array = 0.0 # the width of the signal traveling through the nerve
        self.internodal_length_array = 0.0 # the distance between the node for each axons
        self.width_change = 0.0
               
       
    """
    the analyze nerve data function analyze the data and store them in a more readable
    way
    """    
    def analyze_nerve_data(self):
        self.cut_solution()
        self.internodal_length_array = self.create_internodal()
        self.ap_speed = self.create_ap_speed()
        self.adjust_ap_speed()
        self.nerve_ap = self.calculate_nerve_ap()
        self.nerve_ap_speed = self.calculate_nerve_ap_speed()
        self.width_array = self.calculate_ap_width()
        self.width_change = self.calculate_width_derivative()
        
        
                
    def cut_solution(self):
        """
        The 2 end of the axon was creating problem mathematicly so i decided to create
        a longer axon and cutting the first and last 1/6 of the axon. The rest of this
        module was writed with this in mind. This function cut the nerve.
        """
        damage_array= [[] for x in range(0,self.number_axons,1)]
        temp_array = [0.0 for x in range(0,self.number_axons,1)]
        for x in range(0,self.number_axons,1):
            first_node = int(len(self.sol_array[x][0])/36)
            damage_array[x] = [self.dmg_array[x][y] for y in range(first_node,len(self.dmg_array[x]),1)]
            first_node = first_node*6
            last_node = len(self.sol_array[x][0])-first_node
            temps_length = len(self.sol_array[x])
            a = [[self.sol_array[x][y][z] for z in range(first_node,last_node,1)] for y in range(0,temps_length,1)]
            temp_array[x] = numpy.asanyarray(a)
            
        
        self.length = (self.length*2.0)/3.0
        self.sol_array = temp_array
        self.dmg_array = damage_array
        
        
    def create_internodal(self):
        
        return [(self.length/(len(self.sol_array[x][0])/6)) for x in range(0,self.number_axons,1)]
    
    
    """
    The 2 next function download the file needed to analyse the data. Keep in mind that
    this code was created using my own folder. You may need to edit the next 2 function 
    in order to correctly download the right file.
    """
    def download_axons_solutions(self):
        folder = self.sol_folder
        path = "axon_sol_csv"
        path = os.path.abspath(path)
        path = "%s\%s" %(path,folder) # this path indicate the folder
        sol_array = [0 for x in range(0,self.number_axons,1)]
        
        for x in range(0,self.number_axons,1):
            """
            the files names folder must contain the exact name of the files except the
            csv extension
            """
            temp = "%s.csv" %(self.files_names[x])
            fichier = "%s\%s" %(path,temp)
            axon = open(fichier,'rt')
            axon_reader = csv.reader(axon)
            a = [[float(i) for i in row] for row in axon_reader]
            axon_sol = numpy.asanyarray(a)
            
            print "download axon %d" %x
            sol_array[x] = axon_sol
            
        
        return sol_array
        
    def download_dmg_array(self):
        folder = self.sol_folder
        path = "axon_sol_csv"
        path = os.path.abspath(path)
        path = "%s\%s" %(path,folder)
        temp = self.dmg_file
        fichier = "%s\%s" %(path,temp)
        dmg_file = open(fichier,'rt')
        dmg_reader = csv.reader(dmg_file)
        a = [[float(x) for x in row] for row in dmg_reader]
        return numpy.asanyarray(a)
    
    """
    The 2 next function calculate the ap width and ap speed of the nerve. In my opinion 
    these are the 2 most promising values as they act differently when the nerve is 
    damaged
    """
    def calculate_ap_width(self):
        """
        Since the ap does not travel at the same speed in axons of differents diameters and 
        of different damage the width of the signal measured will change as it travel
        through the nerve. This function calculate the width of the signal at different
        point on the nerve.
        """

        l = len(self.nerve_ap[0])
        
        width_array = [0 for x in range(0,l,1)]
          
        """
        first pulse
        """
        # time array is used to calculate the width of the ap
        time_array = [0.0 for x in range(0,l*2,1)]
        #ap test is used to determine if we are before , in or after the ap
        ap_test = [True for x in range(0,l*2,1)]
        for x in range(0,len(self.temps),1):
            for y in range(0,l,1):
                if self.nerve_ap[x][y] > -55.0 and ap_test[y*2]==True:
                    time_array[y*2] = self.temps[x]
                    ap_test[y*2] = False
                if self.nerve_ap[x][y] < -55.1 and ap_test[y*2]== False and ap_test[(y*2)+1]==True:
                    ap_test[(y*2)+1] = False
                    time_array[(y*2)+1] = self.temps[x]
                
         
        for x in range(0,l,1):
            width_array[x] = time_array[(x*2)+1]-time_array[x*2]
            
        return width_array 
    
    
    def calculate_nerve_ap_speed(self):
        """
        This function calculate the speed at which the action potential travel
        through the nerve at different point. If you take a damaged never you will
        see a bump in the speed of the ap in the area that are damaged.The value
        returned are the speed of the ap at every centimeter of the nerve
        """
        ap_test = [False for x in range(0,len(self.nerve_ap[0]),1)]
        temps = [0.0 for x in range(0,len(self.nerve_ap[0]),1)]
        
        for x in range(0,len(self.temps),1):
            for y in range(0,len(self.nerve_ap[0]),1):
                if self.nerve_ap[x][y] > 10 and ap_test[y] == False:
                    temps[y] = self.temps[x]
                    ap_test[y] == True
        
        longueur = len(self.nerve_ap[0])-1          
        nerve_speed = [0.0 for x in range(0,longueur,1)]
        l1 = 0.0
        n = 0
        delta_length = self.length/len(self.nerve_ap[0])
        for x in range(0,longueur,1):
            if (temps[x+1]-temps[x])>0:
                delta_l = (x+1)*delta_length-l1
                l1 = delta_length*(x+1)
                for y in range(n,x+1,1):
                    nerve_speed[y] = 10*delta_l/(temps[x+1]-temps[x])
                n = x+1
        
        print temps
        print nerve_speed
        return numpy.asanyarray(nerve_speed) 
        
    
    def calculate_nerve_ap(self):
        """
        this function calculate the AP along the nerve at every centimeter
        """
        numpoints = 21
        precise_array = [[0.0 for y in range(0,numpoints,1)] for x in range(0,len(self.temps),1)]
        delta_length = self.length/numpoints
        for y in range(0,len(self.temps),1):
            for x in range(0,numpoints,1):
                temp = 0.0
                for z in range(0,self.number_axons,1):
                    longueur = delta_length*x
                    node = int(longueur/self.internodal_length_array[z])
                    node = node*6
                    temp = self.sol_array[z][y][node] + temp
                
                precise_array[y][x] = temp/self.number_axons
                
        return numpy.asanyarray(precise_array)
        
    def calculate_width_derivative(self):
        """
        this function calculate how the width of the signal change over the length
        of the nerve. This function will only work with very specific value. Note
        the value give is width change at each cm and we start at the 5th cm to 
        remove the effect of the current injection
        """
        array = [0.0 for x in range(6,len(self.width_array),1)]
        for x in range(0,len(array),1):
            array[x] = self.width_array[x+6]-self.width_array[x+5]

        return numpy.asanyarray(array)
        
    def create_ap_speed(self):
        """
        this function calculate the average speed of the ap for every axons.
        """
        
        speed_array = [0 for z in range(0,self.number_axons,1)]
        for x in range(0,self.number_axons,1):
           
            first_pulse = False
            index = 0
            ap_number = 0
            temps_total  = 0.0
            temps1 = 0.0  
            
            for i in range(0, len(self.temps), 1):
                
                if self.sol_array[x][i][0] > 30.0 and index%2 == 0 and first_pulse == False:
                    temps1 = self.temps[i]
                    index = index+1
                    first_pulse = True
                
                elif self.sol_array[x][i][len(self.sol_array[x][0])-6] > 30.0 and index%2 == 1:
                    temps_total = self.temps[i]-temps1 + temps_total
                    index = index+1
                    ap_number = ap_number + 1
                
                elif self.sol_array[x][i][0] < 30.0 and first_pulse == True:
                    # wait for the first pulse to be over before taking another measure
                    first_pulse = False
            
            if ap_number == 0:
                average_time = 0
            else:
                average_time = temps_total/ap_number
            #print "the total time is %f" %temps_total
        
            if average_time < 0.01:
                speed_array[x] = 0.0
            else:
                speed_array[x] = (self.length*10)/average_time
                
        return speed_array
        
    def adjust_ap_speed(self):
        """
        when we cut the axon they do not land exactly on the desired length. because
        of the way i cut the nerve, all the axons are a bit longer from 0-3% longer.
        this function adjust the ap speed array so we get a sense of the real speed
        of the axon action potential. At best it give us a 3% more accurate value
        """
        for x in range(0,self.number_axons,1):
            longueur = len(self.sol_array[x][0])/6
            axon_longueur = self.diameters_array[x]*142.86*longueur
            ratio = axon_longueur/self.length
            self.ap_speed[x] = self.ap_speed[x]*ratio
       
    
    
        
    
    """
    Plot the nerve ap to help visualize the data
    """
    def plot_nerve_ap(self,start= 0,end = 10,name = "none"):
        t = self.temps
        for x in range(0,len(self.nerve_ap[0]),1):
            plt.plot(t,self.nerve_ap[:,x])
        plt.legend(loc = 'upper left')
        plt.title('V par rapport au temps')
        plt.ylabel('V (mV)')
        plt.xlabel('le temps en mS')
        plt.xlim([start,end])
        if name != "none":
           sauvegarde_graphique.save(name, ext="png", close=False, verbose=True)
        plt.show()
        
    def plot_nerve_node(self,node,start = 0,end = 10,name = "none"):
        t = self.temps
        
        plt.plot(t,self.nerve_ap[:,node])
        plt.legend(loc = 'upper left')
        plt.title('V par rapport au temps')
        plt.ylabel('V (mV)')
        plt.xlabel('le temps en mS')
        plt.xlim([start,end])
        if name != "none":
           sauvegarde_graphique.save(name, ext="png", close=False, verbose=True)
        plt.show()
    
    """
    Show how the speed of the nerve ap change as it travel through the nerve
    """
    def plot_nerve_ap_speed(self,start = 0,end = 20,l = "ap speed"):
        numpoints = len(self.nerve_ap_speed)
        length = [self.length*float(i)/(numpoints-1) for i in range(0,numpoints,1)]
        #print self.nerve_ap_speed
        plt.plot(length,self.nerve_ap_speed,label = l)
        plt.legend(loc = 'upper rigth')
        plt.title('nerve ap speed along the nerve')
        plt.ylabel('ap speed in meter per second')
        plt.xlabel('the length in cm')
        plt.xlim([start,end])
        plt.ylim([70.0,100.0])
        #plt.show()

      
    """
    This function plot the different action potential at different node for all
    the axon in the simulation
    """        
    def plot_node_ap(self,start,end):
        t = self.temps
        longueur = len(self.sol_array[0][0])
        
        for x in range(0,self.number_axons,1):
            longueur = len(self.sol_array[x][0])
            for i in range(0,longueur,6):
                plt.plot(t,self.sol_array[x][:,i])            
            plt.legend(loc = 'upper left')
            plt.title('V par rapport au temps')
            plt.ylabel('V (mV)')
            plt.xlabel('le temps en mS')
            plt.xlim([start,end])
            plt.show()
            print "la longueur est : %d" %(longueur/6)
            
    
    """
    Give a average value of the damage at different point in the nerve. Using
    this graph in contrast to the nerve ap width and speed indicate where the
    damage is
    """
    def graph_nerve_damage(self,name = "none"):
        numpoints = 1000
        l = [self.length*float(i)/(numpoints-1) for i in range(numpoints)]
        dmg = [0 for i in range(0,numpoints,1)]
        node_max = len(self.dmg_array[0])
        for y in range(0,numpoints,1):
            temp = 0.0
            for x in range(0,self.number_axons,1):
                node_cm = 1.0/self.internodal_length_array[x]
                divider = numpoints/self.length
                node_length_ratio = divider/node_cm
                node = int(y/node_length_ratio)
                if node >= node_max:
                    node = node_max-1
                    
                temp = self.dmg_array[x][node] + temp
            dmg[y] = temp/self.number_axons
        
        plt.plot(l,dmg)
        if name != "none":
           sauvegarde_graphique.save(name, ext="png", close=False, verbose=True)
        plt.show()
    
    """
    graph the m,h and n value of the  Hodgkin–Huxley model. you need to specifie the
    node and the axon you want to see
    """    
    def show_graph_mhn(self,start,end,n,axon,name = "none"):
        # node must have value 0,6,12,18,24 etc...
        temps = self.temps
        wsol = self.sol_array[axon]
        if n == "last":
            node = len(wsol[0])-6
            print "array length %d" %len(wsol[0])
            print "le dernier node est %d" %node
        else:
            node = n*6
    
        plt.plot(temps, wsol[:,node+1]**3*wsol[:,node+2], label = 'm3h')
        plt.plot(temps, wsol[:,node+1], label = 'm')
        plt.plot(temps, wsol[:,node+2], label = 'h')
        plt.plot(temps, wsol[:,node+3], label = 'n')
        plt.plot(temps, wsol[:,node+3]**4, label = 'n4')
        plt.legend(loc = 'upper right')
        plt.xlabel('Time, t (ms)')
        plt.ylabel('Nav open probability')
        plt.xlim([start,end]) 
        
        if name != "none":
          sauvegarde_graphique.save(name, ext="png", close=False, verbose=True)        
        
        plt.show()
        
    def show_ap_width(self,l = "none"):
        numpoints = len(self.width_array)
        length_array = [self.length*float(i)/(numpoints-1) for i in range(0,numpoints,1)]
        plt.plot(length_array,self.width_array,label = l)
        plt.legend(loc = 'upper rigth')
        plt.ylim([2.8,3.1])
        #plt.show()
        
    def show_ap_speed(self):
        for x in range(0,self.number_axons,1):
            print "the ap average speed of axon %d is %f m/s" %(x,self.ap_speed[x])
            
    def show_node_length(self):
        for x in range(0,len(self.sol_array)):
            longueur = len(self.sol_array[x][0])/6
            axon_longueur = self.diameters_array[x]*142.86*longueur
            pourcent = 100*(axon_longueur/self.length)-100
            print "the number of node in axon %d is : %d" %(x,longueur)
            print "l'axon %d est: %f cm  %f percent off" %(x,axon_longueur,pourcent)
            
    def show_width_derivative(self,l = "width change"):
    
        length = [self.length*float(i)/(20) for i in range(6,21,1)]
        plt.plot(length,self.width_change,label = l)
        plt.legend(loc = 'upper rigth')
        plt.title('The rate of change of the signal width')
        plt.ylabel('Time in millisecond')
        plt.xlabel('the length in cm')
        #plt.show()
        
    def show_speed_statistics(self):
        """
        Show the deviation of the nerve ap speed in relation to the average
        nerve ap speed. We also do not take into account the first few cm since
        the pulse effect on these value is pretty big.
        """
        temp = 0.0
        percent_array = [0.0 for x in range(3,len(self.nerve_ap_speed),1)]
        for x in range(3,len(self.nerve_ap_speed),1):
            temp = self.nerve_ap_speed[x] + temp
        
        average_speed = temp/(len(self.nerve_ap_speed)-3)
        
        for x in range(0,len(percent_array),1):
            percent_array[x] = ((self.nerve_ap_speed[x+3]/average_speed)*100)-100            
    
        print "the percent array"
        print percent_array
        print "the max value: %f" %max(percent_array)
        print "the min value: %f" %min(percent_array)
        print "the average speed: %f" %average_speed
        
        


"""
once you have your data make sure you create a identical time array for my last
simulation i used a time array of 10ms with 2000 step
"""

"""
delta_t = 8
numpoints = 20000
      
temps = [delta_t*float(i)/(numpoints-1) for i in range(0,numpoints,1)]        
d1 = [15e-4,15.5e-4,16e-4,16.5e-4,17e-4,17.5e-4,18e-4,18.5e-4,19e-4,19.5e-4] # the diameters of all the axon in the nerve
d2 = [20e-4,20.5e-4,21e-4,21.5e-4,22e-4,22.5e-4,23e-4,23.5e-4,24e-4,24.5e-4]
diameters = d1 + d2
f1 = ["axon0_0.001500_sol_30cm","axon1_0.001550_sol_30cm","axon2_0.001600_sol_30cm","axon3_0.001650_sol_30cm","axon4_0.001700_sol_30cm"]
f2 = ["axon5_0.001750_sol_30cm","axon6_0.001800_sol_30cm","axon7_0.001850_sol_30cm","axon8_0.001900_sol_30cm","axon9_0.001950_sol_30cm"] 
f3 = ["axon10_0.002000_sol_30cm","axon11_0.002050_sol_30cm","axon12_0.002100_sol_30cm","axon13_0.002150_sol_30cm","axon14_0.002200_sol_30cm",]  
f4 = ["axon15_0.002250_sol_30cm","axon16_0.002300_sol_30cm","axon17_0.002350_sol_30cm","axon18_0.002400_sol_30cm","axon19_0.002450_sol_30cm",]
files_array = f1+f2+f3+f4
"""

delta_t = 10
numpoints = 2000
temps = [delta_t*float(i)/(numpoints-1) for i in range(0,numpoints,1)]

d1 = [8e-4,8e-4,8e-4,8e-4,8e-4,11e-4,11e-4,11e-4,11e-4,11e-4] 
d2 = [20e-4,20e-4,20e-4,20e-4,20e-4,25e-4,25e-4,25e-4,25e-4,25e-4]
diameters = d1 + d2 

f1 = ["axon0_0.000800_sol_30cm","axon1_0.000800_sol_30cm","axon2_0.000800_sol_30cm","axon3_0.000800_sol_30cm","axon4_0.000800_sol_30cm"]
f2 = ["axon5_0.001100_sol_30cm","axon6_0.001100_sol_30cm","axon7_0.001100_sol_30cm","axon8_0.001100_sol_30cm","axon9_0.001100_sol_30cm"] 
f3 = ["axon10_0.002000_sol_30cm","axon11_0.002000_sol_30cm","axon12_0.002000_sol_30cm","axon13_0.002000_sol_30cm","axon14_0.002000_sol_30cm",]  
f4 = ["axon15_0.002500_sol_30cm","axon16_0.002500_sol_30cm","axon17_0.002500_sol_30cm","axon18_0.002500_sol_30cm","axon19_0.002500_sol_30cm",]
files_array = f1+f2+f3+f4


intact_nerve = Use_data(sol_folder = "4type_intact",files_names = files_array,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)
damage_nerve = Use_data(sol_folder = "4type_middle_dmg1",files_names = files_array,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)

intact_nerve.analyze_nerve_data()
damage_nerve.analyze_nerve_data()

intact_nerve.plot_nerve_ap()
damage_nerve.plot_nerve_ap()

for x in range(0,20,1):
    print "node %d" %x
    intact_nerve.plot_nerve_node(node = x)
    damage_nerve.plot_nerve_node(node = x)

intact_nerve.show_ap_speed()



"""
intact_nerve = Use_data(sol_folder = "sol_30cm_intact",step = 5,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)    
middle_dmg = Use_data(sol_folder = "sol_30cm_middle_dmg1",step = 5,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)
damage_random3 = Use_data(sol_folder = "sol_30cm_random_dmg3",step = 5,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)
dmg_random5 = Use_data(sol_folder = "sol_30cm_random_dmg5",step = 5,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)
dmg_rand_15 = Use_data(sol_folder = "sol_30cm_random_dmg1_5",step = 5,dmg_file = "damage_array_30cm.csv",length = 30.0, d = diameters,t = temps)

intact_nerve.analyze_nerve_data()
middle_dmg.analyze_nerve_data()
damage_random3.analyze_nerve_data()
dmg_random5.analyze_nerve_data()
dmg_rand_15.analyze_nerve_data()


intact_nerve.plot_nerve_ap_speed(l = "intact")
middle_dmg.plot_nerve_ap_speed(l = "middle dmg")
damage_random3.plot_nerve_ap_speed(l = "random dmg3")
dmg_random5.plot_nerve_ap_speed(l = "random dmg5")
dmg_rand_15.plot_nerve_ap_speed(l = "random dmg 1.5")
sauvegarde_graphique.save("nerve_ap_speed", ext="png", close=False, verbose=True)
plt.show()

print "\n damaged part \n"
intact_nerve.show_ap_width(l = "intact")
middle_dmg.show_ap_width(l = "middle_dmg")
damage_random3.show_ap_width(l = "random_dmg3")
dmg_random5.show_ap_width(l = "random_dmg5")
dmg_rand_15.show_ap_width(l = "random dmg 1.5")
sauvegarde_graphique.save("nerve_ap_width", ext="png", close=False, verbose=True)
plt.show()

print "\n width derivative \n"
intact_nerve.show_width_derivative(l = "intact")
middle_dmg.show_width_derivative(l = "middle dmg")
damage_random3.show_width_derivative(l = "random dmg3")
dmg_random5.show_width_derivative(l = "random dmg5")
dmg_rand_15.show_width_derivative(l = "random dmg 1.5")
sauvegarde_graphique.save("width_derivative", ext="png", close=False, verbose=True)
plt.show()
print "\n speed statistic \n"
print "intact"
intact_nerve.show_speed_statistics()
print "middle dmg"
middle_dmg.show_speed_statistics()
print "random dmg 3"
damage_random3.show_speed_statistics()
print "random dmg 5"
dmg_random5.show_speed_statistics()
print "random dmg 1.5"
dmg_rand_15.show_speed_statistics()
"""














